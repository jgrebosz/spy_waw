//---------------------------------------------------------------
//        Go4 Framework release package V.1.0000
//                      24-May-2002
//---------------------------------------------------------------
//   The GSI Online Offline Object Oriented (Go4) Project
//   Experiment Data Processing at DVEE department, GSI
//---------------------------------------------------------------
//
//Copyright (C) 2000- Gesellschaft f. Schwerionenforschung, GSI
//                    Planckstr. 1, 64291 Darmstadt, Germany
//Contact:            http://go4.gsi.de
//----------------------------------------------------------------
//This software can be used under the license agreements as stated
//in Go4License.txt file which is part of the distribution.
//----------------------------------------------------------------
/* Generated by Together */

#ifndef TEBEVENTPROCESSOR_H
#define TEBEVENTPROCESSOR_H
//#include "Go4Event/TGo4EventElement.h"
#include <cstring>
#include <cstdlib>
#include "tjurekabstracteventprocessor.h"


class TGalileoEvent;
class TGo4SimpleEvent;
class TGalileoEventProcessor;


#include <vector>
#include <list>
#include <queue>
#include <iterator>
#include <string>

#include <iostream>

#include "Tfile_helper.h"
#include "experiment_def.h"

/**
 * Event processor to build EBEvents from the raw MbsEvents.
 */

/**
 * ----- with many changes by Jurek Grebosz and Alexander Buerger ------
 *
 */


class spectrum_1D ;
class spectrum_2D ;

typedef int old_long;
typedef unsigned int uold_long;
typedef const unsigned int cuold_long;

//#define old_long int

/////////////////////////////////////////////////////////////////////////////////
class vme_header_word
{
public:
    //unsigned int         : 8 ;  // <--- this was in the printed doc, but is not true
unsigned int cnt     :
    14; // 6+8 ;
unsigned int         :
    2 ;
unsigned int crate   :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class vme_data_word
{
public:
unsigned int data    :
    12 ;
unsigned int ov      :
    1 ;
unsigned int un      :
    1 ;
unsigned int         :
    2 ;
unsigned int channel :
    6 ;
unsigned int         :
    2 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class vme_eob_word
{
public:
unsigned int ev_counter   :
    24 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
union vme_word
{
    uold_long        raw_word ;
    vme_header_word      header_word ;
    vme_data_word        data_word ;
    vme_eob_word         end_of_block_word ;
};

/////////////////////////////////////////////////////////////////////////////////
class trigger_14_header_word
{
public:
unsigned int cnt     :
    6 ;
unsigned int         :
    2 ;
unsigned int full_scale_range :
    8 ;
unsigned int forCATE :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class trigger_14_data_word
{
public:
unsigned int threshold    :
    8 ;
unsigned int kill         :
    1 ;
unsigned int        :
    7 ;
unsigned int channel :
    6 ;
unsigned int         :
    2 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class trigger_14_eob_word
{
public:
unsigned int status_register   :
    16 ;
unsigned int         :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////

union trigger_14_word
{
    uold_long        raw_word ;
    trigger_14_header_word      header_word ;
    trigger_14_data_word        data_word ;
    trigger_14_eob_word         end_of_block_word ;
};

//============================================
/////////////////////////////////////////
class vme767_header_word
{
public:
unsigned int evnet_nr:
    12;
unsigned int         :
    9;
    //unsigned int header  : 1;
unsigned int code    :
    2;
unsigned int         :
    4;
unsigned int geo     :
    5 ;
};
/////////////////////////////////////////
class vme767_data_word
{
public:
unsigned int time_data  :
    20;
unsigned int edge       :
    1;
    // unsigned int eob        : 1;
    // unsigned int header     : 1;
unsigned int code    :
    2;
unsigned int start      :
    1;
unsigned int channel    :
    7;
};
/////////////////////////////////////////
class vme767_eob_word
{
public:
unsigned int ev_counter   :
    16 ;
unsigned int  :
    5 ;
    // unsigned int eob        : 1;
    // unsigned int header     : 1;
unsigned int code    :
    2;
unsigned int  :
    1 ;
unsigned int status :
    3 ;
unsigned int geo     :
    5 ;
};
/////////////////////////////////////////
/////////////////////////////////////////
union vme767_word
{
    uold_long           raw_word ;
    vme767_header_word      header_word ;
    vme767_data_word        data_word ;
    vme767_eob_word         end_of_block_word ;
};

union general_vme_word
{
    vme767_word word767;
    vme_word    word775;
};


class Texception_timestamp_corrupted
    {}
;

//----------------------------------------------------------------------------


/////////////////////////////////////////////////////////////
// this class below is a relict and now it helps to make kind
// of statistics and prints
/////////////////////////////////////////////////////////////
class time_stamp_value
{

#ifndef  __CINT__
    // warning this trick with the conditional compilation had to be
    // done, because ROOT does not support "long long"
    // so during "making directory" time, this definition below
    // will be masked

    long long full ;

#endif
    bool flag_1Hz_trigger;


public:
    time_stamp_value(uold_long low = 0,
                     uold_long middle = 0,
                     uold_long high = 0,
                     bool one_Hz = false)
            : flag_1Hz_trigger(one_Hz)
    {
        if ( !time_stamp_ok( low, middle, high ) )
        {
            //      std::cout << "Throwing time stamp corrupted exception because "
            //            << " low = 0x" << std::hex << low
            //            << ", middle = 0x" << std::hex << middle
            //            << ", high = 0x" << std::hex << high
            //            << std::dec << std::endl;

            Texception_timestamp_corrupted obj ;
            throw obj;
        }

        full =  ( ( ((unsigned long long)high & 0xffff ) << 32 )
                  | ((                 middle & 0xffff ) << 16 )
                  |  (                    low & 0xffff ) );

    }

    bool has_1Hz_flag()
    {
        return flag_1Hz_trigger ;
    }


    friend std::ostream& operator<<(std::ostream & s , const time_stamp_value &ts)
    {
        s
        // << ts.high() << ":"   // to make listing narrower we skip the highest part
        // << ((ts.middle() << 16) | ts.low()) ;  // this is slower
        // << ts.two_lower                        // instead i made this, faster
        // << (ts.full & 0x000000ffffff) ;
        << (ts.full) ;
        return s ;
    }

    //----------------------------------------------------------
    long long operator-(time_stamp_value const & ts)
    {
        return full - ts.full ;
    }

    //-----------------------------------------------------------
    //function to check if the time stamps had codes for
    // low middle and high part (0f7, 1f7, 2f7)

    bool time_stamp_ok(unsigned low, unsigned middle, unsigned high )
    {
        return(
                  (
                      (low    & 0xffff0000) == 0x00f70000)
                  &&
                  ((middle & 0xffff0000) == 0x01f70000)
                  &&
                  ((high   & 0xffff0000) == 0x02f70000)
              ) ;
    }

    long long give_ts() const
    {
        return full ;
    }
    //----------------------------

};
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////------------------------
class timestamped_subevent
{
private:


#ifndef  __CINT__
    // warning this trick with the conditional compilation had to be
    // done, because ROOT does not support "long long"
    // so during "making directory" time, this definition below
    // will be masked

    long long time_stamp_value ;

#endif


    std::vector<uold_long> vec ;            // for data words
    //int nr ;                               // nr, only for debugging

public:

    timestamped_subevent(uold_long low, uold_long middle, uold_long high,
                         uold_long *address, int length_long_words
                         //, int n
                        ): vec( address, address+length_long_words )
    {
        //nr = n ;
        if (!time_stamp_identifiers_ok(low, middle, high))
        {
            //        std::cout << "timestamp corrupted " << std::endl ;
            Texception_timestamp_corrupted  obj;
            throw obj  ;
        }

        // they have to be masked below
        time_stamp_value =
            (((unsigned long long)high & 0xffff) << 32)
            | ( ( middle & 0xffff ) << 16 )
            |   ( low    & 0xffff );
    }

    //=====================================================
    // another constructor for situation when the subevent consists of two parts
    //=====================================================
    timestamped_subevent(uold_long low, uold_long middle, uold_long high,
                         uold_long *addressA, int length_long_wordsA,
                         uold_long *addressB, int length_long_wordsB
                        ): vec( addressA, addressA + length_long_wordsA )
    {
        // first part was added in the initilisation list
        // second pard is added now
        vec.resize(length_long_wordsA + length_long_wordsB);
        for (int i = 0 ; i < length_long_wordsB ; i++)
        {
            vec[length_long_wordsA + i] = addressB[i];
        }


        if (!time_stamp_identifiers_ok(low, middle, high))
        {
            //        std::cout << "timestamp corrupted " << std::endl ;
            Texception_timestamp_corrupted  obj;
            throw obj  ;
        }

        // they have to be masked below
        time_stamp_value =
            (((unsigned long long)high & 0xffff) << 32)
            | ( ( middle & 0xffff ) << 16 )
            |   ( low    & 0xffff );
    }

    //--------------------------------

    // function to check if the time stamps had codes for
    // low middle and high part (0f7, 1f7, 2f7)

    static bool time_stamp_identifiers_ok(uold_long low, uold_long middle,uold_long high )
    {
        return
            (
                ((low & 0xffff0000) == 0x00f70000)
                &&
                ((middle & 0xffff0000) == 0x01f70000)
                &&
                ((high & 0xffff0000) == 0x02f70000)
            ) ;
    }
    long long give_ts() const
    {
        return time_stamp_value ;
    }

    //-------------------------------
    long long operator-(timestamped_subevent const & tb) const
    {
        return time_stamp_value - tb.time_stamp_value ;
    }
    //--------------------------------
    uold_long give_word(unsigned int i) const
    {
        if (i < vec.size())
        {
            return vec[i] ;
        }
        else
        {
            return 0 ;
        }
    }

    //---------------------------------
    int length() const
    {
        return vec.size();
    }

    //--------------------------------
    friend std::ostream& operator<<(std::ostream & s , const timestamped_subevent &tb)
    {
        s
        << "["
        //<< tb.nr
        << "], "
        << tb.time_stamp_value
        ;

        return s ;
    }
};

//////////////////////////////////////////////////////////////////////
//* a class which makes kind of lookup table for FRS signals
//////////////////////////////////////////////////////////////////////
class frs_signal
{
    std::string description;
    int crate;  // from which VME crate & slot it comes
    int slot;
    int *where_goes;  // where to put it


public:
    // constructor may be automatically generated
    frs_signal(): description("xxx"), where_goes(0) {} ;
    //***********************************------
    frs_signal(std::ifstream & plik, std::string des, int *wh)
    {

        // read such a std::string from the disc
        crate = Tfile_helper::find_in_file<int> (plik, des);
        if (crate > 21 || crate < 0)
        {
            std::cout << "Lookup table for FRS, item called " << des
            << "has crate nr " << crate << " which is > 21" << std::endl ;
            exit(-1);
        }

        plik >> zjedz >> slot ;
        // check results
        if (slot < 0 || slot > 31)
        {
            std::cout << "Lookup table for FRS, item called " << description
            << "has slot nr " << slot << " which is > 31" << std::endl ;
            exit(-1);
        }
        // if success...
        description = des;
        where_goes = wh;
    }
    // ---------------------------------------

    //------------------------------------
    void put_this_item(uold_long  selected_vme[22][32])
    {
        *where_goes = selected_vme[crate][slot];
        //    std::cout << "Putting signal from crate " << crate << ", slot " << slot
        //           << ", into =" << description << "=" << std::endl;
    }

};
//////////////////////////////////////////////////////////////////////

enum what_to_do { take_another_subevent,       event_ready,      try_another }; // for result of matching funct.

class TGo4EventSourceParameter;
//////////////////////////////////////////////////////////////////////
class TGalileoEventProcessor : public TjurekAbstractEventProcessor
{
    cuold_long*    input_event_data; // one event buffer
    int how_many_data_words; // how many sensible data in the buffer

public:
    TGalileoEventProcessor(std::string name = "EBProcessor");

    void Process()
    {
        std::cout << "Empty TGalileoEventProcessor::Process()" << std::endl;
        // BuildEbEvent(target) ;
    }
    //--------------------------------------------------------


    // Getting the input event from the file, or from the data stream and
    //  returning the pointer to the event
    void *   GetInputEvent() ;  // virtual  !

    void BuildEbEvent(TGo4EventSourceParameter* source_of_events, TGalileoEvent* target);

    virtual ~TGalileoEventProcessor() ;

    /** reading the types of events which are legal
    reading the time gates for time stamp system */
    //  bool read_in_mbs_parameters(  std::string nam_frs_to_hec_timestamp_diff,
    //                                std::string nam_ger_to_frs_timestamp_diff,
    //                                std::string nam_ger_to_hec_timestamp_diff);


    void postLoop();

  

    int * give_addres_of_mbs_event_number();
    /** To have a chance to load the lookup table */
    void preLoop();

    void output_statistics_events();
    
    /** for debuging purposes */
    void show_n_longwords(uold_long *buf, int how_many);
    /** reading the types of events which are legal for 5 branches mode of MBS
    reading the time gates for time stamp system */
   
    /** No descriptions */
   



protected:




    //------------------------------------------------------------

    /** putting to the right owners */
    void distribute_frs_vme_words_to_event_members(TGalileoEvent *te ) ;

    void  swap_nr_words(short int* pointer, int how_many  );


    // we remember for private functions
    TGalileoEvent* target_event ;
    //    TjurekMbsSubEvent* input_subevent;



    uold_long     vmeOne[22][32] ;
    uold_long     vmeUser[22][32] ;



    // --------------- matching when the reference is FRS subevent

    //std::string name_of_hec_to_frs_timestamp_difference_spectrum ;
    //std::string name_of_ger_to_frs_timestamp_difference_spectrum ;





    /** event nr taken from the mbs event structure */
    int current_ev_nr;

    //--------------------------------------------------
    /** making the report of the timestamped subevent matching
       when the matching is made to the GER subevent */
    void make_report_ger_style();
    /** making the report of the timestamped subevent matching
       when the matching is made to the FRS subevent */
    void make_report_frs_style();

    /** When one of the 3 timestamps que is full, we make report and clean them all */

#if ((CURRENT_EXPERIMENT_TYPE == RISING_STOPPED_BEAM_CAMPAIGN) ||         (CURRENT_EXPERIMENT_TYPE == GALILEO_PROTOTYPE) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_APRIL_2008) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_JULY_2008) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_100TIN ))


    int  frs_user_subevents, time_subevents;
#endif


    int unknown_type_subevents ;
    int zero_type_subevents ;


    int frs_hec_dgf_event,
    frs_ger_dgf_event,
    frs_ger_hec_dgf_event ;

    int frs_hec_event,
    frs_dgf_event,
    frs_ger_event,
    frs_ger_hec_event ;

    int ger_hec_dgf_event,
    ger_frs_dgf_event,
    ger_frs_hec_dgf_event ;
    int ger_hec_event,
    ger_dgf_event,
    ger_frs_event,
    ger_frs_hec_event ;

    int ger_matched_single_event,
    frs_matched_single_event;

    // not matched
    int ger_orphan,
    hec_orphan,
    frs_orphan,
    dgf_orphan,
    aga_orphan ;

    int ger_empty ;


    int
    counter_valid,
    counter_put,
    counter_try,
    counter_total,
    counter_nonsense;
    /** The same GER subevent can contain pulser and physics information.
    Here we will mark if there is physics  */
    bool germanium_data_event;
    int ger_pulser , ger_physics, ger_physics_empty ; // for quality check

    bool flag_old_style_pulser_in_b7 ; // during commisioninig experiment
    //bool CheckForGerData( const uold_long* data, int length );

    long long time_stamp_beg_of_last_spill ;

    /** No descriptions */
    void perhaps_one_queue_is_too_big();

//     bool need_FRS;
//     bool need_HEC;
//     bool need_GER;
//     bool need_DGF;
//     bool need_AGA;

    /** No descriptions */

    // what_to_do
//     int matching_to_FRS( TGalileoEvent *te ,
//                          bool flag_frs, bool flag_hec, bool flag_dgf, bool flag_aga);
//     int matching_to_GER( TGalileoEvent *te ,
//                          bool flag_ger, bool flag_hec, bool flag_dgf, bool flag_aga);


    /**  */
    unsigned int ger_synchro_vxi_crate1_group;
    unsigned int ger_synchro_vxi_crate1_item;
    unsigned int ger_synchro_vxi_crate2_group;
    unsigned int ger_synchro_vxi_crate2_item;

    // instead the above counters, now they are collected into the array
    int event_combination[32] ;  // 2**5 (branches) = 32 ;
    /** Reconstruction of the event in case of 5 branches (5 types of subevents: FRS, GER, HEC, DGF, MIN) */
    bool try_to_5reconstruct_event(TGalileoEvent * te);


    //
//     std::vector<frs_signal> frsOne_lookup_table;
//     void read_frsOne_lookup_table();
//     bool frsOne_lookup_should_be_loaded;
// 
//     std::vector<frs_signal> frsUser_lookup_table;
//     void read_frsUser_lookup_table();
//     bool frsUser_lookup_should_be_loaded;

    /** This is the function which reads new style of event - characteristic
    to the fast beam campaign. There is no timestamp matching, everything
    comes together as one event (with subevent parts) */
//     bool unpack_the_fast_beam_campaign_event();

//     bool unpack_timing_module_subevent(
//         const uold_long*  long_data,
//         int how_many_words);

//     bool unpack_munich_timing_module_subevent(
//         const uold_long*  long_data,
//         int how_many_words);

    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block  */
//     bool unpack_frs_subevent_from_raw_array(const uold_long *data, int how_many_words);
//     bool unpack_exotic_event_from_raw_array(const uold_long *data, int how_many_words);
//     bool unpack_active_stopper_subevent_from_raw_array(cuold_long *data,int how_many_words);
// 
//     bool unpack_munich_sam3_subevent_from_raw_array(cuold_long *data,int how_many_words);

    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
//     template <typename typ>
//     bool unpack_dgf_subevent_from_raw_array(typ * data, int how_many_words);

#ifdef NIGDY
    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
    bool unpack_dgf_subevent_from_raw_array(const uold_long * data, int how_many_words);
    // OVERLOADING !!!!!
    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
    bool unpack_dgf_subevent_from_raw_array(const unsigned short * data, int how_many_words);
#endif // NIGDY



    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
//     bool unpack_frsUser_subevent_from_raw_array(const uold_long * data, int how_many_words);

    bool flag_vmeOne_zeroing_needed ; // to zeroin before frs  unpacking function
    bool flag_vmeUser_zeroing_needed ; // to zeroin before  frs_user unpacking function

    int minimal(int a, int b)
    {
        return a < b ? a : b;
    }
    unsigned int minimal(unsigned int a, unsigned int b)
    {
        return a < b ? a : b;
    }

    int maximal(int a, int b)
    {
        return a > b ? a : b;
    }
    unsigned int maximal(unsigned int a, unsigned int b)
    {
        return a > b ? a : b;
    }


    // kind of notebook to  remember the pointers of the time information which
    // have to be subtracted with "plastic" time (see more explanations in the text)
    std::vector<std::pair<int, int*> > to_subtract_reference_time;


//     int decode_munich_absorber_data(const uold_long * data, const uint sim_stop_word);
//     void read_munich_lookup();

//     bool
//     unpack_multi_hit_tdc_v1290_from_raw_array(cuold_long *data,int how_many_words);



//  ClassDef(TGalileoEventProcessor,1)
};

////////////////////////////////////////////////////////////////////////////
#endif //TEBEVENTPROCESSOR_H
